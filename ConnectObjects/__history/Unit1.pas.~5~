unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, GR32_Image,gr32, GR32_VectorUtils, GR32_polygons, GR32_Geometry, GR32_layers, GR32_paths, gr32_arrowheads;

type
  TForm1 = class(TForm)
    img: TImage32;
    procedure FormCreate(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
    lo : TArrayOfArrayOfFloatPoint;
    lp : array of tfloatpoint;
    c1,c2, ip1,ip2 : tfloatpoint;
    Arrow: TArrowHeadAbstract;
    function centropoly(p : tarrayoffloatpoint) : tfloatpoint;
    procedure calcpolys;
    procedure draw;
    function LinePolyIntersect(p1,p2: tfloatpoint; poly : tarrayoffloatpoint; var p :tfloatpoint) : boolean;
    function breakline(p1,p2 : tfloatpoint) : tarrayoffloatpoint;
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function MakeBezierCurve(const CtrlPts: TArrayOfFloatPoint): TArrayOfFloatPoint;
var
  Index: Integer;
begin
  with TFlattenedPath.Create do
  try
    MoveTo(CtrlPts[0]);
    for Index := 0 to (High(CtrlPts) - 3) div 3 do
      CurveTo(CtrlPts[Index * 3 + 1], CtrlPts[Index * 3 + 2],
        CtrlPts[Index * 3 + 3]);
    Result := Points;
  finally
    Free;
  end;
end;

function TForm1.breakline(p1, p2: tfloatpoint): tarrayoffloatpoint;
var
  d : single;
  pm1, pm2 : tfloatpoint;
begin
  d := Distance(p2, p1)*2 / 3;

  //Arrow := TArrowHeadFourPt.Create(15);


  if abs(p2.X - p1.X) > abs(p2.Y - p1.Y) then
  begin
    if p2.X > p1.X then d := -d;
    pm1 := FloatPoint(p2.X + d, p2.Y);
    pm2 := FloatPoint(p1.X - d, p1.Y);
  end
  else
  begin
    if p2.Y > p1.Y then d := -d;
    pm1 := FloatPoint(p2.X, p2.Y + d);
    pm2 := FloatPoint(p1.X, p1.Y - d);
  end;
  result := MakeBezierCurve(BuildPolygonF([p2.X, p2.Y,
         pm1.X, pm1.Y,
         pm2.X, pm2.Y,
    p1.X, p1.Y]));
end;

procedure TForm1.calcpolys;
var
  i : integer;
begin
  for I := 0 to High(lo) do
    lo[i] :=  RoundRect(floatRect(lp[i], floatpoint(lp[i].X + 100, lp[i].Y + 50)), 20);
  c1 := centropoly(lo[0]);
  c2 := centropoly(lo[1]);
  LinePolyIntersect(c1,c2, lo[0], ip1);
  LinePolyIntersect(c1,c2, lo[1], ip2);
    //PolylineFS(img.Bitmap,Lo[i], clblack32, true);

end;

function TForm1.centropoly(p: tarrayoffloatpoint): tfloatpoint;
var
  i : integer;
  fx, fy : tfloat;
begin
  fx := 0; fy := 0;
  for i := 0 to High(p) do
  begin
    fx := fx + p[i].X;
    fy := fy + p[i].Y;
  end;
  result := floatpoint(fx/(high(p)+1),fy/(high(p)+1));
end;

procedure TForm1.draw;
var
  i : integer;
  bl,l,a1,a2 : tarrayoffloatpoint;
  Arrow: TArrowHeadAbstract;
begin
  Img.Bitmap.FillRectS(Img.Bitmap.BoundsRect, clWhite32);

  PolylineFS(img.Bitmap,Lo[0], clblack32, true);
  PolylineFS(img.Bitmap,Lo[1], clblack32, true);
  l := BuildpolygonF([c1.X,c1.Y,c2.X,c2.Y]);

  //PolylineFS(img.Bitmap,L, clblue32, true);

//  PolylineFS(img.Bitmap,circle(ip1,5), clred32, true);
//  PolylineFS(img.Bitmap,circle(ip2,5), clred32, true);

  bl := breakline(ip1,ip2);
  PolylineFS(img.Bitmap,bl,clred32,false);
  bl := Shorten(bl, 15, lpStart);
  bl := Shorten(bl, 15, lpEnd);
  Arrow := TArrowHeadFourPt.Create(15);
  //Arrow.GetPoints(bl, False);
  a1 := Arrow.GetPoints(bl, False);
  a2 := Arrow.GetPoints(bl, true);
  polygonfs(img.Bitmap, a1,clwhite32);
  polygonfs(img.Bitmap, a2,clwhite32);
  PolylineFS(img.Bitmap, Arrow.GetPoints(bl, False), clred32, true);
  PolylineFS(img.Bitmap, Arrow.GetPoints(bl, true), clred32, true);
end;

procedure TForm1.FormCreate(Sender: TObject);
var
  i : integer;
begin
  img.Bitmap := tbitmap32.Create(img.Width, img.Height);

  setlength(lp,2);
  lp[0] := floatpoint(100, 100);
  lp[1] := floatpoint(450, 300);

  setlength(lo,high(lp)+1);
  Arrow := TArrowHeadFourPt.Create(15);
  calcpolys;
  draw;
end;

function TForm1.LinePolyIntersect(p1, p2: tfloatpoint; poly: tarrayoffloatpoint;
  var p: tfloatpoint): boolean;
var
  i : integer;
  pi,pf : tfloatpoint;
begin
  result := SegmentIntersect(p1, p2, poly[0], poly[high(poly)],p);

  if not result then
  for I := 1 to High(poly) do
  begin
    pi := poly[i-1];
    pf := poly[i];
    result := SegmentIntersect(p1, p2, pi, pf,p);
    if result then
      break;
  end;
end;

end.
